<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>MatMul · MoYe.jl</title><meta name="title" content="MatMul · MoYe.jl"/><meta property="og:title" content="MatMul · MoYe.jl"/><meta property="twitter:title" content="MatMul · MoYe.jl"/><meta name="description" content="Documentation for MoYe.jl."/><meta property="og:description" content="Documentation for MoYe.jl."/><meta property="twitter:description" content="Documentation for MoYe.jl."/><meta property="og:url" content="https://YichengDWu.github.io/MoYe.jl/manual/tiling_matmul/"/><meta property="twitter:url" content="https://YichengDWu.github.io/MoYe.jl/manual/tiling_matmul/"/><link rel="canonical" href="https://YichengDWu.github.io/MoYe.jl/manual/tiling_matmul/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">MoYe.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../layout/">Layout</a></li><li><a class="tocitem" href="../array/">Array</a></li><li><a class="tocitem" href="../broadcast/">Broadcasting</a></li><li class="is-active"><a class="tocitem" href>MatMul</a><ul class="internal"><li><a class="tocitem" href="#On-CPU"><span>On CPU</span></a></li><li><a class="tocitem" href="#On-GPU"><span>On GPU</span></a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-5" type="checkbox"/><label class="tocitem" for="menuitem-2-5"><span class="docs-label">Data Movement</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../datamovement/gs/">Global Memory &amp; Shared Memory</a></li></ul></li></ul></li><li><span class="tocitem">API Reference</span><ul><li><a class="tocitem" href="../../api/layout/">Layout</a></li><li><a class="tocitem" href="../../api/array/">MoYeArray</a></li><li><a class="tocitem" href="../../api/tiling/">Tiling</a></li><li><a class="tocitem" href="../../api/copy/">Data Movement</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>MatMul</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>MatMul</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/YichengDWu/MoYe.jl/blob/main/docs/src/manual/tiling_matmul.md#" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="MatMul"><a class="docs-heading-anchor" href="#MatMul">MatMul</a><a id="MatMul-1"></a><a class="docs-heading-anchor-permalink" href="#MatMul" title="Permalink"></a></h1><p>This tutorial demonstrates how to perform matrix multiplication <code>C = A * B^T</code> using <code>MoYe</code>.</p><p>We follow the convention where the shape of matrix <code>A</code> is <code>(M, K)</code>, matrix <code>B</code> is <code>(N, K)</code>, and matrix <code>C</code> is <code>(M, N)</code>.</p><h2 id="On-CPU"><a class="docs-heading-anchor" href="#On-CPU">On CPU</a><a id="On-CPU-1"></a><a class="docs-heading-anchor-permalink" href="#On-CPU" title="Permalink"></a></h2><p>First, we launch Julia with 16 threads:</p><pre><code class="language-julia hljs">julia --threads 16</code></pre><p>Correspondingly, we use a thread layout of</p><pre><code class="language-julia hljs">threadlayout = @Layout (4, 4)</code></pre><p>We start with a simple example, where <code>M = 4, N = 4</code>, and <code>K = 8</code>. In this case, each thread processes one element of matrix <code>C</code>.</p><pre><code class="language-julia hljs">M = 4
N = 4
K = 8
A = reshape([i for i in 1:(M*K)], (M, K))
B = reshape([i for i in 1:(N*K)], (N, K))
C = zeros(Int, M, N)

moye_A = MoYeArray(A, (M, K))
moye_B = MoYeArray(B, (N, K))
moye_C = MoYeArray(C, (M, N))</code></pre><p>After setting up the initial matrices and thread layouts, we can proceed with the tiling process. The <a href="../../api/tiling/#MoYe.@parallelize"><code>@parallelize</code></a> macro is used with a fourth argument, which is the projection. Specifically, the thread IDs of all columns in the thread layout are projected onto the first column, and only the first column is used for tiling. The static(1) is just a placeholder, representing the dimensions that are preserved in the projection.</p><pre><code class="language-julia hljs">threadlayout = @Layout (4, 4)
tile_A = @parallelize moye_A threadlayout 1 (static(1), :)
tile_B = @parallelize moye_B threadlayout 1 (:, static(1))</code></pre><p>Let&#39;s take a look at the contents of tile_A:</p><pre><code class="language-julia hljs">julia&gt; tile_A = @parallelize moye_A threadlayout 1 (static(1), :)
1×8 MoYeArray{Int64, 2, ViewEngine{Int64, Ptr{Int64}}, Layout{2, Tuple{Int64, Int64}, Tuple{StaticInt{4}, Int64}}}:
 1  5  9  13  17  21  25  29</code></pre><p>Thread 1 processes the element in the first row and first column of <code>C</code>, and it needs the elements in the first row of <code>A</code>, which are the contents printed above. Let&#39;s see all the elements of <code>A</code> that Thread 2 needs:</p><pre><code class="language-julia hljs">julia&gt; tile_A = @parallelize moye_A threadlayout 2 (static(1), :)
1×8 MoYeArray{Int64, 2, ViewEngine{Int64, Ptr{Int64}}, Layout{2, Tuple{Int64, Int64}, Tuple{StaticInt{4}, Int64}}}:
 2  6  10  14  18  22  26  30</code></pre><p>This is exactly the second row of <code>A</code>. What about Thread 5? It is processing the entry at the first row and second column of <code>C</code>, so it also needs the first row of <code>A</code>.</p><pre><code class="language-julia hljs">julia&gt; tile_A = @parallelize moye_A threadlayout 5 (static(1), :)
1×8 MoYeArray{Int64, 2, ViewEngine{Int64, Ptr{Int64}}, Layout{2, Tuple{Int64, Int64}, Tuple{StaticInt{4}, Int64}}}:
 1  5  9  13  17  21  25  29</code></pre><p>Great, this is exactly what we want. Now let&#39;s look at <code>tile_B</code>. Threads 1 and 2 both need the first column of <code>B^T</code>, while Thread 5 needs the second column of <code>B^T</code>.</p><pre><code class="language-julia hljs">julia&gt; tile_B = @parallelize moye

julia&gt; tile_B = @parallelize moye_B threadlayout 1 (:, static(1))
1×8 MoYeArray{Int64, 2, ViewEngine{Int64, Ptr{Int64}}, Layout{2, Tuple{Int64, Int64}, Tuple{StaticInt{4}, Int64}}}:
 1  5  9  13  17  21  25  29

julia&gt; tile_B = @parallelize moye_B threadlayout 2 (:, static(1))
1×8 MoYeArray{Int64, 2, ViewEngine{Int64, Ptr{Int64}}, Layout{2, Tuple{Int64, Int64}, Tuple{StaticInt{4}, Int64}}}:
 1  5  9  13  17  21  25  29

julia&gt; tile_B = @parallelize moye_B threadlayout 5 (:, static(1))
1×8 MoYeArray{Int64, 2, ViewEngine{Int64, Ptr{Int64}}, Layout{2, Tuple{Int64, Int64}, Tuple{StaticInt{4}, Int64}}}:
 2  6  10  14  18  22  26  30</code></pre><p>Once the tiling is done, we perform the matrix multiplication using three native loops. The outer loop iterates over the reduction mode <code>K</code>, while the inner two loops handle the row and column indices of the resulting matrix C. These loops are responsible for the actual computation of matrix C&#39;s elements by multiplying the corresponding elements of matrices A and B.</p><pre><code class="language-julia hljs">M = 4*32
N = 4*32
K = 8*32
A = rand(M, K)
B = rand(N, K)
C = zeros(M, N)

threadlayout = @Layout (4, 4)

moye_A = MoYeArray(A, (M, K))
moye_B = MoYeArray(B, (N, K))
moye_C = MoYeArray(C, (M, N))

Threads.@threads :static for i in 1:Threads.nthreads()
    tile_A = @parallelize moye_A threadlayout Threads.threadid() (static(1), :)
    tile_B = @parallelize moye_B threadlayout Threads.threadid() (:, static(1))
    tile_C = @parallelize moye_C threadlayout Threads.threadid()

    for k in axes(tile_A, 2)
        for n in axes(tile_C, 2)
            for m in axes(tile_C, 1)
                tile_C[m, n] += tile_A[m, k] * tile_B[n, k]
            end
        end
    end
end

C ≈ A * transpose(B)</code></pre><h2 id="On-GPU"><a class="docs-heading-anchor" href="#On-GPU">On GPU</a><a id="On-GPU-1"></a><a class="docs-heading-anchor-permalink" href="#On-GPU" title="Permalink"></a></h2><h3 id="Low-level-code"><a class="docs-heading-anchor" href="#Low-level-code">Low-level code</a><a id="Low-level-code-1"></a><a class="docs-heading-anchor-permalink" href="#Low-level-code" title="Permalink"></a></h3><pre><code class="language-julia hljs">using MoYe, CUDA, Test
using MoYe: @loopinfo

function matmul_kernel(A, blocklayout_A, threadlayout_A, B, blocklayout_B, threadlayout_B,
                       C, blocklayout_C, threadlayout_C)
    sA = MoYeSharedArray(eltype(A), blocklayout_A)
    sB = MoYeSharedArray(eltype(B), blocklayout_B)

    X = MoYe.One()

    M = size(A, 1)
    N = size(B, 1)
    K = size(A, 2)

    mA = MoYeArray(A, (M, K))
    mB = MoYeArray(B, (N, K))
    mC = MoYeArray(C, (M, N))

    bM = size(blocklayout_A, 1)
    bN = size(blocklayout_B, 1)
    bK = size(blocklayout_B, 2)

    blocktile_A = @tile mA (bM, bK) (blockIdx().x, :) # (bM,bK,k)
    blocktile_B = @tile mB (bN, bK) (blockIdx().y, :) # (bN,bK,k)
    blocktile_C = @tile mC (bM, bN) (blockIdx().x, blockIdx().y) # (bM,bN)

    # Tiles for loading data A and B from gmem to smem
    threadtile_gA = @parallelize blocktile_A threadlayout_A threadIdx().x # (tM,tK,k)
    threadtile_sA = @parallelize sA threadlayout_A threadIdx().x # (tM,tK）

    threadtile_gB = @parallelize blocktile_B threadlayout_B threadIdx().x # (tN,tK,k)
    threadtile_sB = @parallelize sB threadlayout_B threadIdx().x # (tN,tK）

    # For mma computation
    computetile_sA = @parallelize sA threadlayout_C threadIdx().x (X, :)
    computetile_sB = @parallelize sB threadlayout_C threadIdx().x (:, X)
    computetile_gC = @parallelize blocktile_C threadlayout_C threadIdx().x 

    frg_c = make_fragment_like(computetile_gC)
    zeros!(frg_c)

    for i in axes(threadtile_gA, 3)
        # copy gmem to smem
        copyto!(threadtile_sA, view(threadtile_gA, :, :, i))
        copyto!(threadtile_sB, view(threadtile_gB, :, :, i))
        cp_async_wait()
        sync_threads()

        # classic three nested for loops
        for k in axes(computetile_sA, 2)
            @loopinfo unroll for m in axes(computetile_sA, 1)
                @loopinfo unroll for n in axes(computetile_sB, 1)
                    @inbounds frg_c[m, n] += computetile_sA[m, k] * computetile_sB[n, k]
                end
            end
        end

        sync_threads()
    end
    # copy rmem to gmem
    copyto!(computetile_gC, frg_c)
    return nothing
end

function matmul(A, B, C)
    M = size(A, 1)
    N = size(B, 1)
    K = size(A, 2)

    blocklayout_A = @Layout (128, 8)
    blocklayout_B = @Layout (128, 8)
    blocklayout_C = @Layout (128, 128)

    threadlayout_A = @Layout (32, 8)
    threadlayout_B = @Layout (32, 8)
    threadlayout_C = @Layout (32, 8)

    threads = Int(size(threadlayout_C))

    bM = size(blocklayout_A, 1)
    bN = size(blocklayout_B, 1)

    blocks = (cld(M, bM), cld(N, bN))

    @cuda threads=threads blocks=blocks matmul_kernel(A, blocklayout_A, threadlayout_A,
                                                      B, blocklayout_B, threadlayout_B,
                                                      C, blocklayout_C, threadlayout_C)
end

function test()
    A = CUDA.randn(Float32, 2048, 256)
    B = CUDA.randn(Float32, 2048, 256)
    C = CUDA.randn(Float32, 2048, 2048)
    matmul(A, B, C)
    CUDA.synchronize()
    @test C == A * B&#39;
    CUDA.unsafe_free!(A)
    CUDA.unsafe_free!(B)
    CUDA.unsafe_free!(C)
end</code></pre><h3 id="High-level-code"><a class="docs-heading-anchor" href="#High-level-code">High-level code</a><a id="High-level-code-1"></a><a class="docs-heading-anchor-permalink" href="#High-level-code" title="Permalink"></a></h3><pre><code class="language-julia hljs">function matmul_kernel(A, blocklayout_A, B, blocklayout_B, C, tiled_copy, tiled_mma)
    sA = MoYeSharedArray(eltype(A), blocklayout_A)
    sB = MoYeSharedArray(eltype(B), blocklayout_B)

    M = size(A, 1)
    N = size(B, 1)
    K = size(A, 2)

    mA = MoYeArray(A, (M, K))
    mB = MoYeArray(B, (N, K))
    mC = MoYeArray(C, (M, N))

    bM = size(blocklayout_A, 1)
    bN = size(blocklayout_B, 1)
    bK = size(blocklayout_B, 2)

    blk_A = @tile mA (bM, bK) (blockIdx().x, :) # (bM,bK,k)
    blk_B = @tile mB (bN, bK) (blockIdx().y, :) # (bN,bK,k)
    blk_C = @tile mC (bM, bN) (blockIdx().x, blockIdx().y) # (bM,bN)

    # For mma computation
    thread_idx = Int(threadIdx().x)
    thr_mma = get_thread_slice(tiled_mma, thread_idx)
    thr_A = partition_A(thr_mma, sA)
    thr_B = partition_B(thr_mma, sB)
    thr_C = partition_C(thr_mma, blk_C)

    frg_c = make_fragment_like(thr_C)
    zeros!(frg_c)

    for i in axes(blk_A, 3)
        # copy gmem to smem
        @collective tiled_copy copyto!(sA, view(blk_A, :, :, i))
        @collective tiled_copy copyto!(sB, view(blk_B, :, :, i))

        cp_async_wait()
        sync_threads()

        MoYe.gemm!(tiled_mma, view(frg_c, :), thr_A, thr_B, view(frg_c, :))
        sync_threads()
    end
    # copy rmem to gmem
    copyto!(thr_C, frg_c)
    return nothing
end

function matmul2(A, B, C)
    M = size(A, 1)
    N = size(B, 1)

    blocklayout_A = @Layout (128, 8)
    blocklayout_B = @Layout (128, 8)

    tiled_mma = MoYe.make_tiled_mma(UniversalFMA{Float32, Float32, Float32, Float32}(), @Layout((32,8)))
    tiled_copy = make_tiled_copy(CopyAtom{MoYe.CPOP_ASYNC_CACHEALWAYS{UInt128, UInt128}, Float32}(), @Layout((32,8)), @Layout((4,1)))


    threads = Int(size(tiled_copy))

    bM = size(blocklayout_A, 1)
    bN = size(blocklayout_B, 1)

    blocks = (cld(M, bM), cld(N, bN))

    @cuda threads=threads blocks=blocks matmul_kernel(A, blocklayout_A,
                                                      B, blocklayout_B,
                                                      C, tiled_copy, tiled_mma)
end

function test2()
    A = CUDA.randn(Float32, 2048, 256)
    B = CUDA.randn(Float32, 2048, 256)
    C = CUDA.randn(Float32, 2048, 2048)
    matmul2(A, B, C)
    CUDA.synchronize()
    @test C == A * B&#39;
    CUDA.unsafe_free!(A)
    CUDA.unsafe_free!(B)
    CUDA.unsafe_free!(C)
end
</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../broadcast/">« Broadcasting</a><a class="docs-footer-nextpage" href="../datamovement/gs/">Global Memory &amp; Shared Memory »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.4.0 on <span class="colophon-date" title="Saturday 20 April 2024 11:54">Saturday 20 April 2024</span>. Using Julia version 1.10.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
